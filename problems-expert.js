export const expertProblems = [
  {
    id: 101,
    title: "Customer Lifetime Value",
    difficulty: "expert",
    description: "Calculate the total revenue generated by each customer, their average order value, and total number of orders. Only include customers with completed orders. Show customer name, total_revenue, avg_order_value, and order_count, ordered by total_revenue descending.",
    hint: "Use SUM(), AVG(), and COUNT() together with GROUP BY customer. Filter for completed orders.",
    expectedColumns: ["customer_name", "total_revenue", "avg_order_value", "order_count"],
    solution: `SELECT c.name as customer_name, 
               SUM(o.total_amount) as total_revenue,
               AVG(o.total_amount) as avg_order_value,
               COUNT(o.id) as order_count
               FROM customers c
               JOIN orders o ON c.id = o.customer_id
               WHERE o.status = 'completed'
               GROUP BY c.id, c.name
               ORDER BY total_revenue DESC`,
    explanation: "Customer Lifetime Value (CLV) analysis combines multiple aggregations per customer. We calculate total revenue (SUM), average order value (AVG), and order frequency (COUNT) to understand customer value."
  },
  {
    id: 102,
    title: "Product Profitability Analysis",
    difficulty: "expert",
    description: "Calculate profit margin for each product (price - cost) / price * 100. Show product name, price, cost, profit_margin (as percentage), and category name. Only show products with profit margin > 50%, ordered by profit_margin descending.",
    hint: "Calculate profit margin using arithmetic operations. Use ROUND() for formatting and filter in WHERE clause.",
    expectedColumns: ["product_name", "price", "cost", "profit_margin", "category_name"],
    solution: `SELECT p.name as product_name, p.price, p.cost,
               ROUND(((p.price - p.cost) / p.price * 100), 2) as profit_margin,
               c.name as category_name
               FROM products p
               JOIN categories c ON p.category_id = c.id
               WHERE ((p.price - p.cost) / p.price * 100) > 50
               ORDER BY profit_margin DESC`,
    explanation: "Profit margin = (Revenue - Cost) / Revenue * 100. This shows what percentage of the selling price is profit. We filter for high-margin products (>50%) to identify the most profitable items."
  },
  {
    id: 103,
    title: "Monthly Revenue Trend",
    difficulty: "expert",
    description: "Calculate total revenue for each month in 2023 from completed orders. Show month (YYYY-MM format), total_revenue, and number of orders, ordered by month.",
    expectedColumns: ["month", "total_revenue", "order_count"],
    solution: `SELECT strftime('%Y-%m', order_date) as month,
               SUM(total_amount) as total_revenue,
               COUNT(*) as order_count
               FROM orders
               WHERE status = 'completed' AND order_date LIKE '2023%'
               GROUP BY strftime('%Y-%m', order_date)
               ORDER BY month`
  },
  {
    id: 104,
    title: "Top Products by Revenue",
    difficulty: "expert",
    description: "Find the top 5 products by total revenue. Show product name, total quantity sold, total revenue, and average rating (from reviews). Order by total revenue descending.",
    expectedColumns: ["product_name", "quantity_sold", "total_revenue", "avg_rating"],
    solution: `SELECT p.name as product_name,
               SUM(oi.quantity) as quantity_sold,
               SUM(oi.quantity * oi.unit_price) as total_revenue,
               COALESCE(AVG(r.rating), 0) as avg_rating
               FROM products p
               JOIN order_items oi ON p.id = oi.product_id
               LEFT JOIN reviews r ON p.id = r.product_id
               GROUP BY p.id, p.name
               ORDER BY total_revenue DESC
               LIMIT 5`
  },
  {
    id: 105,
    title: "Customer Segmentation",
    difficulty: "expert",
    description: "Segment customers into 'High Value' (total spent > 2000), 'Medium Value' (1000-2000), and 'Low Value' (< 1000). Show customer name, total_spent, and segment, ordered by total_spent descending.",
    expectedColumns: ["customer_name", "total_spent", "segment"],
    solution: `SELECT c.name as customer_name,
               COALESCE(SUM(CASE WHEN o.status = 'completed' THEN o.total_amount ELSE 0 END), 0) as total_spent,
               CASE
                 WHEN COALESCE(SUM(CASE WHEN o.status = 'completed' THEN o.total_amount ELSE 0 END), 0) > 2000 THEN 'High Value'
                 WHEN COALESCE(SUM(CASE WHEN o.status = 'completed' THEN o.total_amount ELSE 0 END), 0) >= 1000 THEN 'Medium Value'
                 ELSE 'Low Value'
               END as segment
               FROM customers c
               LEFT JOIN orders o ON c.id = o.customer_id
               GROUP BY c.id, c.name
               ORDER BY total_spent DESC`
  },
  {
    id: 106,
    title: "Inventory Turnover Rate",
    difficulty: "expert",
    description: "Calculate inventory turnover for each product (total quantity sold / current inventory quantity). Show product name, quantity_sold, current_stock, and turnover_rate. Only include products that have been sold, ordered by turnover_rate descending.",
    expectedColumns: ["product_name", "quantity_sold", "current_stock", "turnover_rate"],
    solution: `SELECT p.name as product_name,
               SUM(oi.quantity) as quantity_sold,
               i.quantity as current_stock,
               ROUND(CAST(SUM(oi.quantity) AS FLOAT) / i.quantity, 2) as turnover_rate
               FROM products p
               JOIN order_items oi ON p.id = oi.product_id
               JOIN inventory i ON p.id = i.product_id
               GROUP BY p.id, p.name, i.quantity
               ORDER BY turnover_rate DESC`
  },
  {
    id: 107,
    title: "Category Performance Comparison",
    difficulty: "expert",
    description: "Compare parent categories by total revenue, number of products, and average product rating. Show category name, product_count, total_revenue, and avg_product_rating. Only include parent categories (parent_id IS NULL).",
    expectedColumns: ["category_name", "product_count", "total_revenue", "avg_product_rating"],
    solution: `SELECT c.name as category_name,
               COUNT(DISTINCT p.id) as product_count,
               COALESCE(SUM(oi.quantity * oi.unit_price), 0) as total_revenue,
               COALESCE(AVG(r.rating), 0) as avg_product_rating
               FROM categories c
               LEFT JOIN categories c2 ON c.id = c2.parent_id
               LEFT JOIN products p ON (p.category_id = c.id OR p.category_id = c2.id)
               LEFT JOIN order_items oi ON p.id = oi.product_id
               LEFT JOIN reviews r ON p.id = r.product_id
               WHERE c.parent_id IS NULL
               GROUP BY c.id, c.name`
  },
  {
    id: 108,
    title: "Repeat Customer Rate",
    difficulty: "expert",
    description: "Find customers who have made more than one completed order. Show customer name, total_orders, first_order_date, last_order_date, and days_between_orders (difference between first and last order).",
    hint: "Use MIN() and MAX() for dates, julianday() for date arithmetic, and HAVING to filter for repeat customers.",
    expectedColumns: ["customer_name", "total_orders", "first_order_date", "last_order_date", "days_between_orders"],
    solution: `SELECT c.name as customer_name,
               COUNT(o.id) as total_orders,
               MIN(o.order_date) as first_order_date,
               MAX(o.order_date) as last_order_date,
               CAST((julianday(MAX(o.order_date)) - julianday(MIN(o.order_date))) AS INTEGER) as days_between_orders
               FROM customers c
               JOIN orders o ON c.id = o.customer_id
               WHERE o.status = 'completed'
               GROUP BY c.id, c.name
               HAVING COUNT(o.id) > 1
               ORDER BY total_orders DESC`,
    explanation: "Repeat customers are valuable for business. We use MIN/MAX to find first and last order dates, and julianday() to calculate the difference in days. This helps understand customer retention and purchase frequency."
  },
  {
    id: 109,
    title: "Supplier Performance Score",
    difficulty: "expert",
    description: "Calculate a performance score for each supplier based on: average product rating * supplier rating * number of products. Show supplier name, product_count, avg_product_rating, supplier_rating, and performance_score, ordered by performance_score descending.",
    expectedColumns: ["supplier_name", "product_count", "avg_product_rating", "supplier_rating", "performance_score"],
    solution: `SELECT s.name as supplier_name,
               COUNT(DISTINCT p.id) as product_count,
               COALESCE(AVG(r.rating), 0) as avg_product_rating,
               s.rating as supplier_rating,
               ROUND(COALESCE(AVG(r.rating), 0) * s.rating * COUNT(DISTINCT p.id), 2) as performance_score
               FROM suppliers s
               JOIN products p ON s.id = p.supplier_id
               LEFT JOIN reviews r ON p.id = r.product_id
               GROUP BY s.id, s.name, s.rating
               ORDER BY performance_score DESC`
  },
  {
    id: 110,
    title: "Cross-Sell Analysis",
    difficulty: "expert",
    description: "Find products that are frequently bought together. For each product, find other products purchased in the same order. Show product1_name, product2_name, and times_bought_together. Exclude same product pairs and duplicates (e.g., if A-B exists, don't show B-A). Minimum 2 times bought together.",
    hint: "Self-join order_items on order_id. Use product_id < product_id to avoid duplicates.",
    expectedColumns: ["product1_name", "product2_name", "times_bought_together"],
    solution: `SELECT p1.name as product1_name,
               p2.name as product2_name,
               COUNT(*) as times_bought_together
               FROM order_items oi1
               JOIN order_items oi2 ON oi1.order_id = oi2.order_id AND oi1.product_id < oi2.product_id
               JOIN products p1 ON oi1.product_id = p1.id
               JOIN products p2 ON oi2.product_id = p2.id
               GROUP BY p1.id, p1.name, p2.id, p2.name
               HAVING COUNT(*) >= 2
               ORDER BY times_bought_together DESC`,
    explanation: "Cross-sell analysis identifies product pairs frequently purchased together (like 'customers who bought X also bought Y'). We self-join order_items to find products in the same order, using product_id < product_id to avoid showing both A-B and B-A."
  },
  {
    id: 111,
    title: "Revenue by Country",
    difficulty: "expert",
    description: "Calculate total revenue and average order value for each country. Show country, total_revenue, avg_order_value, customer_count, and order_count. Only include completed orders, ordered by total_revenue descending.",
    expectedColumns: ["country", "total_revenue", "avg_order_value", "customer_count", "order_count"],
    solution: `SELECT c.country,
               SUM(o.total_amount) as total_revenue,
               AVG(o.total_amount) as avg_order_value,
               COUNT(DISTINCT c.id) as customer_count,
               COUNT(o.id) as order_count
               FROM customers c
               JOIN orders o ON c.id = o.customer_id
               WHERE o.status = 'completed'
               GROUP BY c.country
               ORDER BY total_revenue DESC`
  },
  {
    id: 112,
    title: "Low Stock Alert",
    difficulty: "expert",
    description: "Identify products that need restocking. Calculate expected monthly sales based on total sales, and flag products where current stock < 2 months of expected sales. Show product name, current_stock, monthly_sales_rate, months_of_stock_remaining, and needs_restock (1 if < 2 months, 0 otherwise).",
    expectedColumns: ["product_name", "current_stock", "monthly_sales_rate", "months_of_stock_remaining", "needs_restock"],
    solution: `SELECT p.name as product_name,
               i.quantity as current_stock,
               COALESCE(SUM(oi.quantity) / 1.0, 0) as monthly_sales_rate,
               CASE 
                 WHEN COALESCE(SUM(oi.quantity), 0) > 0 THEN ROUND(i.quantity * 1.0 / (SUM(oi.quantity) / 1.0), 2)
                 ELSE 999
               END as months_of_stock_remaining,
               CASE
                 WHEN COALESCE(SUM(oi.quantity), 0) > 0 AND i.quantity * 1.0 / (SUM(oi.quantity) / 1.0) < 2 THEN 1
                 ELSE 0
               END as needs_restock
               FROM products p
               JOIN inventory i ON p.id = i.product_id
               LEFT JOIN order_items oi ON p.id = oi.product_id
               GROUP BY p.id, p.name, i.quantity
               ORDER BY months_of_stock_remaining`
  }
];
